<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::CompositorShadowNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_compositor_shadow_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_compositor_shadow_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::CompositorShadowNode Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___effects.html">Effects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Shadow Nodes are special nodes (not to be confused with.  
 <a href="class_ogre_1_1_compositor_shadow_node.html#details">More...</a></p>

<p><code>#include &lt;OgreCompositorShadowNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::CompositorShadowNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_compositor_shadow_node__inherit__graph.svg" width="280" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac572709b6988d13b7e02634914bf531d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a></td></tr>
<tr class="separator:ac572709b6988d13b7e02634914bf531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5079bdbf967ccd4ecd67d97b532c4efa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5079bdbf967ccd4ecd67d97b532c4efa">CompositorShadowNode</a> (<a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> id, const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *definition, <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *workspace, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSys, const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *finalTarget)</td></tr>
<tr class="separator:a5079bdbf967ccd4ecd67d97b532c4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd092a04aa6951fd9760f0619c3515"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ae2cd092a04aa6951fd9760f0619c3515">~CompositorShadowNode</a> ()</td></tr>
<tr class="separator:ae2cd092a04aa6951fd9760f0619c3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce752629491b6fb8d140b73df4f4900"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a3ce752629491b6fb8d140b73df4f4900">_getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName) const</td></tr>
<tr class="separator:a3ce752629491b6fb8d140b73df4f4900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d01a7d665365ca2f917337374b29d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aca9d01a7d665365ca2f917337374b29d">_getPasses</a> () const</td></tr>
<tr class="separator:aca9d01a7d665365ca2f917337374b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9042470e9bdae1869d9c4adbe6605cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a9042470e9bdae1869d9c4adbe6605cb9">_notifyCleared</a> (void)</td></tr>
<tr class="memdesc:a9042470e9bdae1869d9c4adbe6605cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Use.  <a href="class_ogre_1_1_compositor_node.html#a9042470e9bdae1869d9c4adbe6605cb9">More...</a><br /></td></tr>
<tr class="separator:a9042470e9bdae1869d9c4adbe6605cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9eb4f664cb4048c4ff035b705b9adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeb9eb4f664cb4048c4ff035b705b9adb">_placeBarriersAndEmulateUavExecution</a> (<a class="el" href="struct_ogre_1_1_bound_uav.html">BoundUav</a> boundUavs[64], <a class="el" href="group___resources.html#gaf3069e13b1cf5ad9102ad2c90eefcb04">ResourceAccessMap</a> &amp;uavsAccess, <a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;resourcesLayout)</td></tr>
<tr class="separator:aeb9eb4f664cb4048c4ff035b705b9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158173d3bd07eb2a591fbf0410ad5f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a158173d3bd07eb2a591fbf0410ad5f52">_removeAllBarriers</a> (void)</td></tr>
<tr class="separator:a158173d3bd07eb2a591fbf0410ad5f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab515beadc41042109d2bddac504b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#abab515beadc41042109d2bddac504b1c">_setFinalTargetAsRenderTarget</a> (ResourceLayoutMap::iterator finalTargetCurrentLayout)</td></tr>
<tr class="memdesc:abab515beadc41042109d2bddac504b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a resource transition in our last pass to the given <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a>.  <a href="class_ogre_1_1_compositor_node.html#abab515beadc41042109d2bddac504b1c">More...</a><br /></td></tr>
<tr class="separator:abab515beadc41042109d2bddac504b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227313a84e19bafb0d69f287273a9562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a227313a84e19bafb0d69f287273a9562">_shouldUpdateShadowMapIdx</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="separator:a227313a84e19bafb0d69f287273a9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1fd121847d6d0f349ae207dac52af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a69f1fd121847d6d0f349ae207dac52af">_update</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *camera, const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:a69f1fd121847d6d0f349ae207dac52af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders into the shadow map, executes passes.  <a href="class_ogre_1_1_compositor_shadow_node.html#a69f1fd121847d6d0f349ae207dac52af">More...</a><br /></td></tr>
<tr class="separator:a69f1fd121847d6d0f349ae207dac52af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e112618b5ed2936391b2bfc45d224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aad4e112618b5ed2936391b2bfc45d224">_update</a> (const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *lodCamera, <a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:aad4e112618b5ed2936391b2bfc45d224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this function every frame will cause us to execute all our passes (ie.  <a href="class_ogre_1_1_compositor_node.html#aad4e112618b5ed2936391b2bfc45d224">More...</a><br /></td></tr>
<tr class="separator:aad4e112618b5ed2936391b2bfc45d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e74226d1c4fe91e2a2886459aba8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a183e74226d1c4fe91e2a2886459aba8a">areAllInputsConnected</a> () const</td></tr>
<tr class="separator:a183e74226d1c4fe91e2a2886459aba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2960e9ca1de509c9c3ff36d847997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a5dd2960e9ca1de509c9c3ff36d847997">connectBufferTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a5dd2960e9ca1de509c9c3ff36d847997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version)  <a href="class_ogre_1_1_compositor_node.html#a5dd2960e9ca1de509c9c3ff36d847997">More...</a><br /></td></tr>
<tr class="separator:a5dd2960e9ca1de509c9c3ff36d847997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aeed3172d72e30cbd79ef663c8c1adfd7">connectExternalBuffer</a> (<a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer, size_t inChannelA)</td></tr>
<tr class="memdesc:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external buffer into the given channel.  <a href="class_ogre_1_1_compositor_node.html#aeed3172d72e30cbd79ef663c8c1adfd7">More...</a><br /></td></tr>
<tr class="separator:aeed3172d72e30cbd79ef663c8c1adfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1815e2b15c8860d9e726e5e884a5569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ac1815e2b15c8860d9e726e5e884a5569">connectExternalRT</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;externalTexture, size_t inChannelA)</td></tr>
<tr class="memdesc:ac1815e2b15c8860d9e726e5e884a5569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects (injects) an external RT into the given channel.  <a href="class_ogre_1_1_compositor_node.html#ac1815e2b15c8860d9e726e5e884a5569">More...</a><br /></td></tr>
<tr class="separator:ac1815e2b15c8860d9e726e5e884a5569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfd8041dbce265afd92ac9c11769fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb">connectTo</a> (size_t outChannelA, <a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *nodeB, size_t inChannelB)</td></tr>
<tr class="memdesc:a0bfd8041dbce265afd92ac9c11769fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version)  <a href="class_ogre_1_1_compositor_node.html#a0bfd8041dbce265afd92ac9c11769fbb">More...</a><br /></td></tr>
<tr class="separator:a0bfd8041dbce265afd92ac9c11769fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae0d443c369fb5e9d26ec20300c85aaf7">createPasses</a> (void)</td></tr>
<tr class="memdesc:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all passes based on our definition.  <a href="class_ogre_1_1_compositor_node.html#ae0d443c369fb5e9d26ec20300c85aaf7">More...</a><br /></td></tr>
<tr class="separator:ae0d443c369fb5e9d26ec20300c85aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958822429b172906dbe491456313e0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a7958822429b172906dbe491456313e0b">finalTargetResized</a> (const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *finalTarget)</td></tr>
<tr class="memdesc:a7958822429b172906dbe491456313e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a> was resized, thus our RTs that depend on their resolution need to be recreated.  <a href="class_ogre_1_1_compositor_shadow_node.html#a7958822429b172906dbe491456313e0b">More...</a><br /></td></tr>
<tr class="separator:a7958822429b172906dbe491456313e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885826b2dc46c5323685b2dd9019a443"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a885826b2dc46c5323685b2dd9019a443">getAffectedLightsBitSet</a> (void) const</td></tr>
<tr class="separator:a885826b2dc46c5323685b2dd9019a443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55280f3dbe04abff8b8970b57fd79807"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a55280f3dbe04abff8b8970b57fd79807">getCastersBox</a> (void) const</td></tr>
<tr class="memdesc:a55280f3dbe04abff8b8970b57fd79807"><td class="mdescLeft">&#160;</td><td class="mdescRight">@See mCastersBox  <a href="class_ogre_1_1_compositor_shadow_node.html#a55280f3dbe04abff8b8970b57fd79807">More...</a><br /></td></tr>
<tr class="separator:a55280f3dbe04abff8b8970b57fd79807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2f68e07073ec66c72802f04238a53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___material.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a64e2f68e07073ec66c72802f04238a53">getContiguousShadowMapTex</a> (void) const</td></tr>
<tr class="separator:a64e2f68e07073ec66c72802f04238a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b7d68042cf5df7ae8c21e979d79a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#aa72b7d68042cf5df7ae8c21e979d79a6">getDefinedBuffer</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="memdesc:aa72b7d68042cf5df7ae8c21e979d79a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pointer of a buffer based on it's name.  <a href="class_ogre_1_1_compositor_node.html#aa72b7d68042cf5df7ae8c21e979d79a6">More...</a><br /></td></tr>
<tr class="separator:aa72b7d68042cf5df7ae8c21e979d79a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e26b77afceb3009026f25bf4e28fa74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a0e26b77afceb3009026f25bf4e28fa74">getDefinedBufferNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> bufferName) const</td></tr>
<tr class="separator:a0e26b77afceb3009026f25bf4e28fa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab475fdb4a07f0510ebf10ac9fe3fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a8ab475fdb4a07f0510ebf10ac9fe3fd0">getDefinedTexture</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> textureName, size_t mrtIndex) const</td></tr>
<tr class="memdesc:a8ab475fdb4a07f0510ebf10ac9fe3fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture pointer of a texture based on it's name &amp; mrt index.  <a href="class_ogre_1_1_compositor_node.html#a8ab475fdb4a07f0510ebf10ac9fe3fd0">More...</a><br /></td></tr>
<tr class="separator:a8ab475fdb4a07f0510ebf10ac9fe3fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e193914b21b147b25e043afdef526"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#af94e193914b21b147b25e043afdef526">getDefinition</a> () const</td></tr>
<tr class="separator:af94e193914b21b147b25e043afdef526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb5a80fd98925d54d327fb49a5aeb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a2efb5a80fd98925d54d327fb49a5aeb8">getEnabled</a> (void) const</td></tr>
<tr class="memdesc:a2efb5a80fd98925d54d327fb49a5aeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this instance is enabled. @See setEnabled.  <a href="class_ogre_1_1_compositor_node.html#a2efb5a80fd98925d54d327fb49a5aeb8">More...</a><br /></td></tr>
<tr class="separator:a2efb5a80fd98925d54d327fb49a5aeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c8f646a835c2f88585ad4fe0413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">getId</a> () const</td></tr>
<tr class="memdesc:ab152c8f646a835c2f88585ad4fe0413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of this object.  <a href="class_ogre_1_1_id_object.html#ab152c8f646a835c2f88585ad4fe0413a">More...</a><br /></td></tr>
<tr class="separator:ab152c8f646a835c2f88585ad4fe0413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5768e502ca461ede1ba8398a50792843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5768e502ca461ede1ba8398a50792843">getIndexToContiguousShadowMapTex</a> (size_t shadowMapIdx) const</td></tr>
<tr class="separator:a5768e502ca461ede1ba8398a50792843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a944243155926c133ba5643b767462"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ac3a944243155926c133ba5643b767462">getInputChannel</a> () const</td></tr>
<tr class="separator:ac3a944243155926c133ba5643b767462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af823c9d086d37a866a7165cf4b98c3ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#af823c9d086d37a866a7165cf4b98c3ac">getLightAssociatedWith</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="memdesc:af823c9d086d37a866a7165cf4b98c3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: May return null if there is no such shadowMapIdx, or if there is no light that could be linked with that shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#af823c9d086d37a866a7165cf4b98c3ac">More...</a><br /></td></tr>
<tr class="separator:af823c9d086d37a866a7165cf4b98c3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735cd2dc2db53df7b8d363334709565c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a735cd2dc2db53df7b8d363334709565c">getLocalTextures</a> () const</td></tr>
<tr class="separator:a735cd2dc2db53df7b8d363334709565c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7297ac09456ceff0056a7a0d03f88c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#afc7297ac09456ceff0056a7a0d03f88c">getMinMaxDepthRange</a> (const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *shadowMapCamera, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMin, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMax) const</td></tr>
<tr class="memdesc:afc7297ac09456ceff0056a7a0d03f88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the min &amp; max depth range for the given camera.  <a href="class_ogre_1_1_compositor_shadow_node.html#afc7297ac09456ceff0056a7a0d03f88c">More...</a><br /></td></tr>
<tr class="separator:afc7297ac09456ceff0056a7a0d03f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912abb5a026185c4380b04856137fafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a912abb5a026185c4380b04856137fafd">getMinMaxDepthRange</a> (size_t shadowMapIdx, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMin, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;outMax) const</td></tr>
<tr class="separator:a912abb5a026185c4380b04856137fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7b35c76faf97bd638e3ed2e5c1f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#af4a7b35c76faf97bd638e3ed2e5c1f40">getName</a> (void) const</td></tr>
<tr class="separator:af4a7b35c76faf97bd638e3ed2e5c1f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32513ad6dd803013451dda44660d9ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ab32513ad6dd803013451dda44660d9ba">getNumActiveShadowCastingLights</a> (void) const</td></tr>
<tr class="memdesc:ab32513ad6dd803013451dda44660d9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return value may change in the future, which happens when the number of lights changes to or from a value lower than the supported shadow casting lights by the definition.  <a href="class_ogre_1_1_compositor_shadow_node.html#ab32513ad6dd803013451dda44660d9ba">More...</a><br /></td></tr>
<tr class="separator:ab32513ad6dd803013451dda44660d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329444d41283a85be5e6191c525aedef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a329444d41283a85be5e6191c525aedef">getPassNumber</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass) const</td></tr>
<tr class="separator:a329444d41283a85be5e6191c525aedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4489a1e485ffded34e91f56ba24da1f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a4489a1e485ffded34e91f56ba24da1f5">getPssmBlends</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a4489a1e485ffded34e91f56ba24da1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of points with the blend band boundaries of the closest N-1 PSSM split in projection space for the given shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#a4489a1e485ffded34e91f56ba24da1f5">More...</a><br /></td></tr>
<tr class="separator:a4489a1e485ffded34e91f56ba24da1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4420e858f24df8997598da950579f374"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a4420e858f24df8997598da950579f374">getPssmFade</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a4420e858f24df8997598da950579f374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fade point of the last PSSM split in projection space for the given shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#a4420e858f24df8997598da950579f374">More...</a><br /></td></tr>
<tr class="separator:a4420e858f24df8997598da950579f374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d95735afda16b2785d3da3aee60b218"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5d95735afda16b2785d3da3aee60b218">getPssmSplits</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a5d95735afda16b2785d3da3aee60b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of points with the limits of each PSSM split in projection space for the given shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#a5d95735afda16b2785d3da3aee60b218">More...</a><br /></td></tr>
<tr class="separator:a5d95735afda16b2785d3da3aee60b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c47731293c3dd6b7507e921b4f9ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a91c47731293c3dd6b7507e921b4f9ab3">getRenderSystem</a> (void) const</td></tr>
<tr class="separator:a91c47731293c3dd6b7507e921b4f9ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8a4eac1d4bb17ddc193d2d314dfb05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___general.html#ga8795828980c8be4892c41f4f4b7a7337">LightClosestArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a1d8a4eac1d4bb17ddc193d2d314dfb05">getShadowCastingLights</a> (void) const</td></tr>
<tr class="separator:a1d8a4eac1d4bb17ddc193d2d314dfb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa015e01b5e725c3b8016e10cb5408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ae2fa015e01b5e725c3b8016e10cb5408">getShadowMapLightTypeMask</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="memdesc:ae2fa015e01b5e725c3b8016e10cb5408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call this if isShadowMapIdxActive == false or isShadowMapIdxInValidRange == false.  <a href="class_ogre_1_1_compositor_shadow_node.html#ae2fa015e01b5e725c3b8016e10cb5408">More...</a><br /></td></tr>
<tr class="separator:ae2fa015e01b5e725c3b8016e10cb5408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab540330b747d4c89d028d1016beef1d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ab540330b747d4c89d028d1016beef1d1">getViewMatrix</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:ab540330b747d4c89d028d1016beef1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture view matrix for the given shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#ab540330b747d4c89d028d1016beef1d1">More...</a><br /></td></tr>
<tr class="separator:ab540330b747d4c89d028d1016beef1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ce2ecc67f6585db0da69dfc4146037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a86ce2ecc67f6585db0da69dfc4146037">getViewProjectionMatrix</a> (size_t shadowMapIdx) const</td></tr>
<tr class="memdesc:a86ce2ecc67f6585db0da69dfc4146037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture view projection matrix for the given shadow map index.  <a href="class_ogre_1_1_compositor_shadow_node.html#a86ce2ecc67f6585db0da69dfc4146037">More...</a><br /></td></tr>
<tr class="separator:a86ce2ecc67f6585db0da69dfc4146037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a3ffe9f2a0e8fd48f57d3e2693fb181be">getWorkspace</a> (void)</td></tr>
<tr class="memdesc:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <a href="class_ogre_1_1_compositor_node.html#a3ffe9f2a0e8fd48f57d3e2693fb181be">More...</a><br /></td></tr>
<tr class="separator:a3ffe9f2a0e8fd48f57d3e2693fb181be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba729d149a2f99f28f74c233a04b980"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a7ba729d149a2f99f28f74c233a04b980">getWorkspace</a> (void) const</td></tr>
<tr class="memdesc:a7ba729d149a2f99f28f74c233a04b980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our parent workspace.  <a href="class_ogre_1_1_compositor_node.html#a7ba729d149a2f99f28f74c233a04b980">More...</a><br /></td></tr>
<tr class="separator:a7ba729d149a2f99f28f74c233a04b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe50bca433a0e8f6d2239e189922539"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#aefe50bca433a0e8f6d2239e189922539">isShadowMapIdxActive</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="memdesc:aefe50bca433a0e8f6d2239e189922539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shadow map index is not active.  <a href="class_ogre_1_1_compositor_shadow_node.html#aefe50bca433a0e8f6d2239e189922539">More...</a><br /></td></tr>
<tr class="separator:aefe50bca433a0e8f6d2239e189922539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0104d92ad5a14a2e36a92f46e9bfe88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#aa0104d92ad5a14a2e36a92f46e9bfe88">isShadowMapIdxInValidRange</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> shadowMapIdx) const</td></tr>
<tr class="separator:aa0104d92ad5a14a2e36a92f46e9bfe88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a95aaefe91c3d2d7bb040e2e3e74f9408">notifyDestroyed</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;channel)</td></tr>
<tr class="memdesc:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when caller has destroyed a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> in which the callee may have a reference to that pointer, so that we can clean it up.  <a href="class_ogre_1_1_compositor_node.html#a95aaefe91c3d2d7bb040e2e3e74f9408">More...</a><br /></td></tr>
<tr class="separator:a95aaefe91c3d2d7bb040e2e3e74f9408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9edc7379e9c8759de9abb0baaf2135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a6e9edc7379e9c8759de9abb0baaf2135">notifyDestroyed</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *buffer)</td></tr>
<tr class="separator:a6e9edc7379e9c8759de9abb0baaf2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081b18ad77e67e1d5e561ceb61933bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a081b18ad77e67e1d5e561ceb61933bbf">notifyRecreated</a> (const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;oldChannel, const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;newChannel)</td></tr>
<tr class="memdesc:a081b18ad77e67e1d5e561ceb61933bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you're replacing the textures from oldChannel with the ones in newChannel.  <a href="class_ogre_1_1_compositor_node.html#a081b18ad77e67e1d5e561ceb61933bbf">More...</a><br /></td></tr>
<tr class="separator:a081b18ad77e67e1d5e561ceb61933bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e7c49813462a88761ff73f514d7ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a01e7c49813462a88761ff73f514d7ce8">notifyRecreated</a> (const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *oldBuffer, <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *newBuffer)</td></tr>
<tr class="separator:a01e7c49813462a88761ff73f514d7ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ac4bdf968b7b9af8a5239a27da73d5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b197ca3a38da17e2eb1531a645fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a421b197ca3a38da17e2eb1531a645fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a421b197ca3a38da17e2eb1531a645fa2">More...</a><br /></td></tr>
<tr class="separator:a421b197ca3a38da17e2eb1531a645fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78a921e54419be677839cdf15d1f0b8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:ab78a921e54419be677839cdf15d1f0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="class_ogre_1_1_allocated_object.html#ab78a921e54419be677839cdf15d1f0b8">More...</a><br /></td></tr>
<tr class="separator:ab78a921e54419be677839cdf15d1f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2943846ba6a2b5824a12857139cf5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:afa2943846ba6a2b5824a12857139cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be37baef81876985aa1071ad5acc6dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:a4be37baef81876985aa1071ad5acc6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#a4be37baef81876985aa1071ad5acc6dd">More...</a><br /></td></tr>
<tr class="separator:a4be37baef81876985aa1071ad5acc6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0523432c6e5133ff4fc251111a60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a57e0523432c6e5133ff4fc251111a60e">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;right)</td></tr>
<tr class="separator:a57e0523432c6e5133ff4fc251111a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_id_object.html#a0ae22596b5bd2a3faf2958ab3d109d1f">operator()</a> (const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *left, const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *right)</td></tr>
<tr class="separator:a0ae22596b5bd2a3faf2958ab3d109d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f992849380f39c5f1b02ab1b7b860a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a3f992849380f39c5f1b02ab1b7b860a3">postInitializePass</a> (<a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *pass)</td></tr>
<tr class="memdesc:a3f992849380f39c5f1b02ab1b7b860a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">We derive so we can override the camera with ours.  <a href="class_ogre_1_1_compositor_shadow_node.html#a3f992849380f39c5f1b02ab1b7b860a3">More...</a><br /></td></tr>
<tr class="separator:a3f992849380f39c5f1b02ab1b7b860a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693eac3a7af913adfbb28ba49935842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ae693eac3a7af913adfbb28ba49935842">resetAllNumPassesLeft</a> (void)</td></tr>
<tr class="memdesc:ae693eac3a7af913adfbb28ba49935842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of passes left for every pass (.  <a href="class_ogre_1_1_compositor_node.html#ae693eac3a7af913adfbb28ba49935842">More...</a><br /></td></tr>
<tr class="separator:ae693eac3a7af913adfbb28ba49935842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817bc10dbf5427a77912ab3bcd391f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69">setEnabled</a> (bool bEnabled)</td></tr>
<tr class="memdesc:a817bc10dbf5427a77912ab3bcd391f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables all instances of this node.  <a href="class_ogre_1_1_compositor_node.html#a817bc10dbf5427a77912ab3bcd391f69">More...</a><br /></td></tr>
<tr class="separator:a817bc10dbf5427a77912ab3bcd391f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#acf4e9f7b9d8e5b8c61bce6d164185e5d">setLightFixedToShadowMap</a> (size_t shadowMapIdx, <a class="el" href="class_ogre_1_1_light.html">Light</a> *light)</td></tr>
<tr class="memdesc:acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a shadow map as statically updated, and ties the given light to always use that shadow map.  <a href="class_ogre_1_1_compositor_shadow_node.html#acf4e9f7b9d8e5b8c61bce6d164185e5d">More...</a><br /></td></tr>
<tr class="separator:acf4e9f7b9d8e5b8c61bce6d164185e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f91a021268284eec9fecc8913d9b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___general.html#ga9870d1f08a71391b8716b43bb2064b2d">LightList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#abe9f91a021268284eec9fecc8913d9b9">setShadowMapsToPass</a> (<a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *rend, const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> *pass, <a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *autoParamDataSource, size_t startLight)</td></tr>
<tr class="separator:abe9f91a021268284eec9fecc8913d9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607c30415819742ad2bcfaa1d3959d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a607c30415819742ad2bcfaa1d3959d5a">setStaticShadowMapDirty</a> (size_t shadowMapIdx, bool includeLinked=true)</td></tr>
<tr class="memdesc:a607c30415819742ad2bcfaa1d3959d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags a static shadow map as dirty, causing <a class="el" href="namespace_ogre.html">Ogre</a> to update it on the next time this Shadow node gets executed.  <a href="class_ogre_1_1_compositor_shadow_node.html#a607c30415819742ad2bcfaa1d3959d5a">More...</a><br /></td></tr>
<tr class="separator:a607c30415819742ad2bcfaa1d3959d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#ad2eb91ac8d2a01147d9623ce9e0a8020">fillResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;compositorChannels, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides a resource with the given layout if it's already in outResourcesLayout.  <a href="class_ogre_1_1_compositor_node.html#ad2eb91ac8d2a01147d9623ce9e0a8020">More...</a><br /></td></tr>
<tr class="separator:ad2eb91ac8d2a01147d9623ce9e0a8020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd13076afe5697f54967d82db43403"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#a7fdd13076afe5697f54967d82db43403">initResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;compositorChannels, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:a7fdd13076afe5697f54967d82db43403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only inits a resource with the given layout if it wasn't already in outResourcesLayout.  <a href="class_ogre_1_1_compositor_node.html#a7fdd13076afe5697f54967d82db43403">More...</a><br /></td></tr>
<tr class="separator:a7fdd13076afe5697f54967d82db43403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc51f87af9846e88b03c932dc79ac0af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_compositor_node.html#adc51f87af9846e88b03c932dc79ac0af">initResourcesLayout</a> (<a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;outResourcesLayout, const <a class="el" href="group___effects.html#gabe54b22d0cf0eb77a49fed877816fe2d">CompositorNamedBufferVec</a> &amp;buffers, <a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a> layout)</td></tr>
<tr class="memdesc:adc51f87af9846e88b03c932dc79ac0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only inits a resource with the given layout if it wasn't already in outResourcesLayout.  <a href="class_ogre_1_1_compositor_node.html#adc51f87af9846e88b03c932dc79ac0af">More...</a><br /></td></tr>
<tr class="separator:adc51f87af9846e88b03c932dc79ac0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shadow Nodes are special nodes (not to be confused with. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_node.html" title="Compositor nodes are the core subject of compositing.">CompositorNode</a>) that are only used for rendering shadow maps. Normal Compositor Nodes can share or own a ShadowNode. The ShadowNode will render the scene enough times to fill all shadow maps so the main scene pass can use them. </dd></dl>
<dl class="section user"><dt></dt><dd>ShadowNode are very flexible compared to <a class="el" href="namespace_ogre.html">Ogre</a> 1.x; as they allow mixing multiple shadow camera setups for different lights. </dd></dl>
<dl class="section user"><dt></dt><dd>Shadow Nodes derive from nodes so that they can be used as regular nodes </dd></dl>
<dl class="section user"><dt></dt><dd>During a render with shadow mapping enabled, we render first the Shadow <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>'s pass, then render the regular scene. In the past there used to be an AABB enclosing all visible objects that receive shadows that was used for calculating the shadow maps. This forced <a class="el" href="namespace_ogre.html">Ogre</a> 2.x to split rendering into two stages: _cullPhase01 &amp; _renderPhase02. This is not needed anymore.</dd></dl>
<p>To summarize: a normal rendering flow with shadow map looks like this: shadowNode-&gt;setupShadowCamera( normal-&gt;getVisibleBoundsInfo() ); shadowNode-&gt;_cullPhase01(); shadowNode-&gt;_renderPhase02(); normal-&gt;_cullPhase01(); normal-&gt;_renderPhase02(); </p><dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>On forward lighting passes, shadow mapping is handled in the following way: 1) Build a list of all lights visible by all cameras (<a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does this) 2) Traverse the list to get the closest lights to the current camera. These lights will cast shadows. 3) Build a list of the closest lights for each object (<a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does this) 4) Traverse this list and find those that are actually casting a shadow 5) Send to the GPU &amp; engine the list in step 4, but shadow casting lights are put first, then sorted by proximity. See the comments inside the function setShadowMapsToPass for more information. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matias N. Goldberg </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac572709b6988d13b7e02634914bf531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572709b6988d13b7e02634914bf531d">&#9670;&nbsp;</a></span>LightsBitSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;bool&gt;::type <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">Ogre::CompositorShadowNode::LightsBitSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5079bdbf967ccd4ecd67d97b532c4efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5079bdbf967ccd4ecd67d97b532c4efa">&#9670;&nbsp;</a></span>CompositorShadowNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::CompositorShadowNode::CompositorShadowNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a> *&#160;</td>
          <td class="paramname"><em>definition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2cd092a04aa6951fd9760f0619c3515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cd092a04aa6951fd9760f0619c3515">&#9670;&nbsp;</a></span>~CompositorShadowNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::CompositorShadowNode::~CompositorShadowNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ce752629491b6fb8d140b73df4f4900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce752629491b6fb8d140b73df4f4900">&#9670;&nbsp;</a></span>_getDefinedTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a>* Ogre::CompositorNode::_getDefinedTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>textureName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca9d01a7d665365ca2f917337374b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9d01a7d665365ca2f917337374b29d">&#9670;&nbsp;</a></span>_getPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa09712589d0e729a928ed664b98e30a7">CompositorPassVec</a>&amp; Ogre::CompositorNode::_getPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9042470e9bdae1869d9c4adbe6605cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9042470e9bdae1869d9c4adbe6605cb9">&#9670;&nbsp;</a></span>_notifyCleared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_notifyCleared </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal Use. </p>
<p>Called when connections are all being zero'ed. We rely our caller is doing this to all nodes, hence we do not notify our @mConnectedNodes nodes. Failing to clear them too may leave dangling pointers or graphical glitches </p><dl class="section remark"><dt>Remarks</dt><dd>Destroys all of our passes. </dd></dl>

</div>
</div>
<a id="aeb9eb4f664cb4048c4ff035b705b9adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9eb4f664cb4048c4ff035b705b9adb">&#9670;&nbsp;</a></span>_placeBarriersAndEmulateUavExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_placeBarriersAndEmulateUavExecution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_bound_uav.html">BoundUav</a>&#160;</td>
          <td class="paramname"><em>boundUavs</em>[64], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#gaf3069e13b1cf5ad9102ad2c90eefcb04">ResourceAccessMap</a> &amp;&#160;</td>
          <td class="paramname"><em>uavsAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>resourcesLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass.html#ad75735f2516fb15f48a875d078cbc505" title="Emulates the execution of a UAV to understand memory dependencies, and adds a memory barrier / resour...">CompositorPass::_placeBarriersAndEmulateUavExecution</a> </dd></dl>

</div>
</div>
<a id="a158173d3bd07eb2a591fbf0410ad5f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158173d3bd07eb2a591fbf0410ad5f52">&#9670;&nbsp;</a></span>_removeAllBarriers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_removeAllBarriers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass.html#a57ce009ce1f8c325d12c522210127d58">CompositorPass::_removeAllBarriers</a> </dd></dl>

</div>
</div>
<a id="abab515beadc41042109d2bddac504b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab515beadc41042109d2bddac504b1c">&#9670;&nbsp;</a></span>_setFinalTargetAsRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_setFinalTargetAsRenderTarget </td>
          <td>(</td>
          <td class="paramtype">ResourceLayoutMap::iterator&#160;</td>
          <td class="paramname"><em>finalTargetCurrentLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a resource transition in our last pass to the given <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a>. </p>
<p>Usually needed to ensure the final '<a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a>' is still a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> after the workspace is finished. </p>

</div>
</div>
<a id="a227313a84e19bafb0d69f287273a9562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227313a84e19bafb0d69f287273a9562">&#9670;&nbsp;</a></span>_shouldUpdateShadowMapIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::_shouldUpdateShadowMapIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f1fd121847d6d0f349ae207dac52af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1fd121847d6d0f349ae207dac52af">&#9670;&nbsp;</a></span>_update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders into the shadow map, executes passes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td><a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> used to calculate our shadow camera (in case of directional lights). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad4e112618b5ed2936391b2bfc45d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4e112618b5ed2936391b2bfc45d224">&#9670;&nbsp;</a></span>_update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>lodCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling this function every frame will cause us to execute all our passes (ie. </p>
<p>render) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodCamera</td><td>LOD <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> to be used by our passes. Pointer can be null, and note however passes can ignore this hint and use their own camera pointer for LOD (this parameter is mostly used for syncing shadow mapping). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183e74226d1c4fe91e2a2886459aba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183e74226d1c4fe91e2a2886459aba8a">&#9670;&nbsp;</a></span>areAllInputsConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::areAllInputsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dd2960e9ca1de509c9c3ff36d847997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd2960e9ca1de509c9c3ff36d847997">&#9670;&nbsp;</a></span>connectBufferTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectBufferTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (buffer version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed3172d72e30cbd79ef663c8c1adfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed3172d72e30cbd79ef663c8c1adfd7">&#9670;&nbsp;</a></span>connectExternalBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects (injects) an external buffer into the given channel. </p>
<p>Usually used for the 'connect_buffer_external' directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1815e2b15c8860d9e726e5e884a5569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1815e2b15c8860d9e726e5e884a5569">&#9670;&nbsp;</a></span>connectExternalRT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectExternalRT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>externalTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects (injects) an external RT into the given channel. </p>
<p>Usually used for the "connect_output" / "connect_external" directive for the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a>. </td></tr>
    <tr><td class="paramname">textures</td><td>The Textures associated with the RT. Can be empty (eg. <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a>) but could cause crashes/exceptions if tried to use in PASS_QUAD passes. </td></tr>
    <tr><td class="paramname">inChannelA</td><td>In which channel number to inject to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bfd8041dbce265afd92ac9c11769fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfd8041dbce265afd92ac9c11769fbb">&#9670;&nbsp;</a></span>connectTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::connectTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outChannelA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_node.html">CompositorNode</a> *&#160;</td>
          <td class="paramname"><em>nodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inChannelB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects this node (let's call it node 'A') to node 'B', mapping the output channel from A into the input channel from B (texture version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outChannelA</td><td>Output to use from node A. </td></tr>
    <tr><td class="paramname">inChannelB</td><td>Input to connect the output from A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0d443c369fb5e9d26ec20300c85aaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d443c369fb5e9d26ec20300c85aaf7">&#9670;&nbsp;</a></span>createPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::createPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates all passes based on our definition. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function after connecting all channels (at least our input) otherwise we may bind null pointer RTs to the passes (and then crash) @See connectTo and </dd></dl>
<dl class="section see"><dt>See also</dt><dd>connectFinalRT </dd></dl>

</div>
</div>
<a id="ad2eb91ac8d2a01147d9623ce9e0a8020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eb91ac8d2a01147d9623ce9e0a8020">&#9670;&nbsp;</a></span>fillResourcesLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::fillResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td>
          <td class="paramname"><em>compositorChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides a resource with the given layout if it's already in outResourcesLayout. </p>

</div>
</div>
<a id="a7958822429b172906dbe491456313e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7958822429b172906dbe491456313e0b">&#9670;&nbsp;</a></span>finalTargetResized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorShadowNode::finalTargetResized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_render_target.html">RenderTarget</a> *&#160;</td>
          <td class="paramname"><em>finalTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="class_ogre_1_1_compositor_manager2.html" title="Main system for managing Render Targets through the use of nodes.">CompositorManager2</a> when (i.e.) the <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a> was resized, thus our RTs that depend on their resolution need to be recreated. </p>
<dl class="section remark"><dt>Remarks</dt><dd>We inform all connected nodes and passes related to us of RenderTargets/Textures that may have been recreated (pointers could become danlging otherwise). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalTarget</td><td>The Final Target (i.e. <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window.">RenderWindow</a>) from which we'll base our local textures' resolution. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_node.html#a8bde2d2a53ca30e7bbc3bd3c9c4b569d">Ogre::CompositorNode</a>.</p>

</div>
</div>
<a id="a885826b2dc46c5323685b2dd9019a443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885826b2dc46c5323685b2dd9019a443">&#9670;&nbsp;</a></span>getAffectedLightsBitSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_shadow_node.html#ac572709b6988d13b7e02634914bf531d">LightsBitSet</a>&amp; Ogre::CompositorShadowNode::getAffectedLightsBitSet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55280f3dbe04abff8b8970b57fd79807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55280f3dbe04abff8b8970b57fd79807">&#9670;&nbsp;</a></span>getCastersBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::CompositorShadowNode::getCastersBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>@See mCastersBox </p>

</div>
</div>
<a id="a64e2f68e07073ec66c72802f04238a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e2f68e07073ec66c72802f04238a53">&#9670;&nbsp;</a></span>getContiguousShadowMapTex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___material.html#gae94be61ca436b40d1ab92080010fa909">TextureVec</a>&amp; Ogre::CompositorShadowNode::getContiguousShadowMapTex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa72b7d68042cf5df7ae8c21e979d79a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72b7d68042cf5df7ae8c21e979d79a6">&#9670;&nbsp;</a></span>getDefinedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::CompositorNode::getDefinedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer pointer of a buffer based on it's name. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer may come from a local buffer, an input buffer, or global (workspace). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferName</td><td>The name of the buffer. This name may only be valid at node scope. It can refer to an input buffer, a local buffer, or a global one. If a local or input buffer has the same name as a global one, the global one is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Regular: The buffer. Throws if buffer wasn't found. No throw version: Null if not found. The buffer otherwise </dd></dl>

</div>
</div>
<a id="a0e26b77afceb3009026f25bf4e28fa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e26b77afceb3009026f25bf4e28fa74">&#9670;&nbsp;</a></span>getDefinedBufferNoThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a>* Ogre::CompositorNode::getDefinedBufferNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>bufferName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ab475fdb4a07f0510ebf10ac9fe3fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab475fdb4a07f0510ebf10ac9fe3fd0">&#9670;&nbsp;</a></span>getDefinedTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> Ogre::CompositorNode::getDefinedTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mrtIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the texture pointer of a texture based on it's name &amp; mrt index. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The texture name must have been registered with <a class="el" href="class_ogre_1_1_texture_definition_base.html#a02ec073273bf07eb78122ddb2a4606f1" title="Adds a texture name, whether a real one or an alias, and where to grab it from.">CompositorNodeDef::addTextureSourceName</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The name of the texture. This name may only be valid at node scope. It can refer to an input texture, a local texture, or a global one. If the global texture wasn't registered with addTextureSourceName, it will fail. </td></tr>
    <tr><td class="paramname">mrtIndex</td><td>The MRT (Multiple Render Target) index. If the texture isn't MRT or has less RTs than the index, it returns the highest valid index found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null if not found (or global texture not registered). The texture otherwise </dd></dl>

</div>
</div>
<a id="af94e193914b21b147b25e043afdef526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94e193914b21b147b25e043afdef526">&#9670;&nbsp;</a></span>getDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_shadow_node_def.html">CompositorShadowNodeDef</a>* Ogre::CompositorShadowNode::getDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2efb5a80fd98925d54d327fb49a5aeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb5a80fd98925d54d327fb49a5aeb8">&#9670;&nbsp;</a></span>getEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorNode::getEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this instance is enabled. @See setEnabled. </p>

</div>
</div>
<a id="ab152c8f646a835c2f88585ad4fe0413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab152c8f646a835c2f88585ad4fe0413a">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#afcab9522fbe8edb20b32fbb5d8a48ed5">IdType</a> Ogre::IdObject::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique id of this object. </p>

</div>
</div>
<a id="a5768e502ca461ede1ba8398a50792843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5768e502ca461ede1ba8398a50792843">&#9670;&nbsp;</a></span>getIndexToContiguousShadowMapTex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::CompositorShadowNode::getIndexToContiguousShadowMapTex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3a944243155926c133ba5643b767462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a944243155926c133ba5643b767462">&#9670;&nbsp;</a></span>getInputChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a>&amp; Ogre::CompositorNode::getInputChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af823c9d086d37a866a7165cf4b98c3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af823c9d086d37a866a7165cf4b98c3ac">&#9670;&nbsp;</a></span>getLightAssociatedWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_light.html">Light</a>* Ogre::CompositorShadowNode::getLightAssociatedWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: May return null if there is no such shadowMapIdx, or if there is no light that could be linked with that shadow map index. </p>
<p>i.e. if isShadowMapIdxActive( shadowMapIdx ) is true, then we'll return a valid pointer. </p>

</div>
</div>
<a id="a735cd2dc2db53df7b8d363334709565c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735cd2dc2db53df7b8d363334709565c">&#9670;&nbsp;</a></span>getLocalTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a>&amp; Ogre::CompositorNode::getLocalTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc7297ac09456ceff0056a7a0d03f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7297ac09456ceff0056a7a0d03f88c">&#9670;&nbsp;</a></span>getMinMaxDepthRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::getMinMaxDepthRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_frustum.html">Frustum</a> *&#160;</td>
          <td class="paramname"><em>shadowMapCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the min &amp; max depth range for the given camera. </p>
<p>0 &amp; 100000 if camera not found </p><dl class="section remark"><dt>Remarks</dt><dd>Performs linear search O(N), except the overload that provides a shadowMapIdx </dd></dl>

</div>
</div>
<a id="a912abb5a026185c4380b04856137fafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912abb5a026185c4380b04856137fafd">&#9670;&nbsp;</a></span>getMinMaxDepthRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::getMinMaxDepthRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>outMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a7b35c76faf97bd638e3ed2e5c1f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7b35c76faf97bd638e3ed2e5c1f40">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::CompositorNode::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab32513ad6dd803013451dda44660d9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32513ad6dd803013451dda44660d9ba">&#9670;&nbsp;</a></span>getNumActiveShadowCastingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::CompositorShadowNode::getNumActiveShadowCastingLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The return value may change in the future, which happens when the number of lights changes to or from a value lower than the supported shadow casting lights by the definition. </p>

</div>
</div>
<a id="a329444d41283a85be5e6191c525aedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329444d41283a85be5e6191c525aedef">&#9670;&nbsp;</a></span>getPassNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::CompositorNode::getPassNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a4489a1e485ffded34e91f56ba24da1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4489a1e485ffded34e91f56ba24da1f5">&#9670;&nbsp;</a></span>getPssmBlends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&gt;::type* Ogre::CompositorShadowNode::getPssmBlends </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of points with the blend band boundaries of the closest N-1 PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5d95735afda16b2785d3da3aee60b218" title="Returns a list of points with the limits of each PSSM split in projection space for the given shadow ...">getPssmSplits</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An array with the blend points. The number of elements is N-1 where N is the number of splits for that shadow map. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="a4420e858f24df8997598da950579f374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4420e858f24df8997598da950579f374">&#9670;&nbsp;</a></span>getPssmFade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>* Ogre::CompositorShadowNode::getPssmFade </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fade point of the last PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_shadow_node.html#a5d95735afda16b2785d3da3aee60b218" title="Returns a list of points with the limits of each PSSM split in projection space for the given shadow ...">getPssmSplits</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The fade point. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="a5d95735afda16b2785d3da3aee60b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d95735afda16b2785d3da3aee60b218">&#9670;&nbsp;</a></span>getPssmSplits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&gt;::type* Ogre::CompositorShadowNode::getPssmSplits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of points with the limits of each PSSM split in projection space for the given shadow map index. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If shadow map 0, 1 &amp; 2 use light 0 with different splits, the return value should be the same for all of them. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An array with the split points. The number of elements is N+1 where N is the number of splits for that shadow map. Returns null if shadowMapIdx is out of bounds, or is not a PSSM technique. </dd></dl>

</div>
</div>
<a id="a91c47731293c3dd6b7507e921b4f9ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c47731293c3dd6b7507e921b4f9ab3">&#9670;&nbsp;</a></span>getRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a>* Ogre::CompositorNode::getRenderSystem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d8a4eac1d4bb17ddc193d2d314dfb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8a4eac1d4bb17ddc193d2d314dfb05">&#9670;&nbsp;</a></span>getShadowCastingLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___general.html#ga8795828980c8be4892c41f4f4b7a7337">LightClosestArray</a>&amp; Ogre::CompositorShadowNode::getShadowCastingLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2fa015e01b5e725c3b8016e10cb5408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa015e01b5e725c3b8016e10cb5408">&#9670;&nbsp;</a></span>getShadowMapLightTypeMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::CompositorShadowNode::getShadowMapLightTypeMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not call this if isShadowMapIdxActive == false or isShadowMapIdxInValidRange == false. </p>

</div>
</div>
<a id="ab540330b747d4c89d028d1016beef1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab540330b747d4c89d028d1016beef1d1">&#9670;&nbsp;</a></span>getViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&amp; Ogre::CompositorShadowNode::getViewMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture view matrix for the given shadow map index. </p>

</div>
</div>
<a id="a86ce2ecc67f6585db0da69dfc4146037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ce2ecc67f6585db0da69dfc4146037">&#9670;&nbsp;</a></span>getViewProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> Ogre::CompositorShadowNode::getViewProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture view projection matrix for the given shadow map index. </p>

</div>
</div>
<a id="a3ffe9f2a0e8fd48f57d3e2693fb181be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffe9f2a0e8fd48f57d3e2693fb181be">&#9670;&nbsp;</a></span>getWorkspace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a>* Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a id="a7ba729d149a2f99f28f74c233a04b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba729d149a2f99f28f74c233a04b980">&#9670;&nbsp;</a></span>getWorkspace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_compositor_workspace.html">CompositorWorkspace</a>* Ogre::CompositorNode::getWorkspace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our parent workspace. </p>

</div>
</div>
<a id="a7fdd13076afe5697f54967d82db43403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdd13076afe5697f54967d82db43403">&#9670;&nbsp;</a></span>initResourcesLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::initResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#ga1b4b8ae78da8288aeb191b819c0d72d3">CompositorChannelVec</a> &amp;&#160;</td>
          <td class="paramname"><em>compositorChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only inits a resource with the given layout if it wasn't already in outResourcesLayout. </p>

</div>
</div>
<a id="adc51f87af9846e88b03c932dc79ac0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc51f87af9846e88b03c932dc79ac0af">&#9670;&nbsp;</a></span>initResourcesLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::CompositorNode::initResourcesLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#ga3fd32f5ef28aea13747ce05849f54fa1">ResourceLayoutMap</a> &amp;&#160;</td>
          <td class="paramname"><em>outResourcesLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___effects.html#gabe54b22d0cf0eb77a49fed877816fe2d">CompositorNamedBufferVec</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_resource_layout.html#a7ce11be54143fb01a34d6b7529ba3dc7">ResourceLayout::Layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only inits a resource with the given layout if it wasn't already in outResourcesLayout. </p>

</div>
</div>
<a id="aefe50bca433a0e8f6d2239e189922539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe50bca433a0e8f6d2239e189922539">&#9670;&nbsp;</a></span>isShadowMapIdxActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::isShadowMapIdxActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the shadow map index is not active. </p>
<p>For example:</p><ul>
<li>There are 3 shadow maps, but only 2 shadow casting lights</li>
<li>There are 3 directional maps for directional PSSM, but no directional light. </li>
</ul>

</div>
</div>
<a id="aa0104d92ad5a14a2e36a92f46e9bfe88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0104d92ad5a14a2e36a92f46e9bfe88">&#9670;&nbsp;</a></span>isShadowMapIdxInValidRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::CompositorShadowNode::isShadowMapIdxInValidRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95aaefe91c3d2d7bb040e2e3e74f9408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aaefe91c3d2d7bb040e2e3e74f9408">&#9670;&nbsp;</a></span>notifyDestroyed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when caller has destroyed a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> in which the callee may have a reference to that pointer, so that we can clean it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel containing the pointer about to be destroyed (must still be valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e9edc7379e9c8759de9abb0baaf2135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9edc7379e9c8759de9abb0baaf2135">&#9670;&nbsp;</a></span>notifyDestroyed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyDestroyed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a081b18ad77e67e1d5e561ceb61933bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081b18ad77e67e1d5e561ceb61933bbf">&#9670;&nbsp;</a></span>notifyRecreated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>oldChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_compositor_channel.html">CompositorChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>newChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you're replacing the textures from oldChannel with the ones in newChannel. </p>
<p>Useful when recreating textures (i.e. resolution changed) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldChannel</td><td>The old textures that are going to be removed. Pointers in it must be still valid </td></tr>
    <tr><td class="paramname">newChannel</td><td>The new replacement textures </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01e7c49813462a88761ff73f514d7ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e7c49813462a88761ff73f514d7ce8">&#9670;&nbsp;</a></span>notifyRecreated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::notifyRecreated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>oldBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>newBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4bdf968b7b9af8a5239a27da73d5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdf968b7b9af8a5239a27da73d5711">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a421b197ca3a38da17e2eb1531a645fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b197ca3a38da17e2eb1531a645fa2">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="ab78a921e54419be677839cdf15d1f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78a921e54419be677839cdf15d1f0b8">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="afa2943846ba6a2b5824a12857139cf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2943846ba6a2b5824a12857139cf5e">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4be37baef81876985aa1071ad5acc6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be37baef81876985aa1071ad5acc6dd">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a57e0523432c6e5133ff4fc251111a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e0523432c6e5133ff4fc251111a60e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ae22596b5bd2a3faf2958ab3d109d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae22596b5bd2a3faf2958ab3d109d1f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::IdObject::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_id_object.html">IdObject</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f992849380f39c5f1b02ab1b7b860a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f992849380f39c5f1b02ab1b7b860a3">&#9670;&nbsp;</a></span>postInitializePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::CompositorShadowNode::postInitializePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_compositor_pass.html">CompositorPass</a> *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We derive so we can override the camera with ours. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_compositor_node.html">Ogre::CompositorNode</a>.</p>

</div>
</div>
<a id="ae693eac3a7af913adfbb28ba49935842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae693eac3a7af913adfbb28ba49935842">&#9670;&nbsp;</a></span>resetAllNumPassesLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::resetAllNumPassesLeft </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the number of passes left for every pass (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_compositor_pass_def.html#a70ba2384e061021d6eceb5dd20b66d47" title="Number of times to perform the pass before stopping. -1 to never stop.">CompositorPassDef::mNumInitialPasses</a>) Useful when you have a few starting 'initialization' passes and you want to reset them. </dd></dl>

</div>
</div>
<a id="a817bc10dbf5427a77912ab3bcd391f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817bc10dbf5427a77912ab3bcd391f69">&#9670;&nbsp;</a></span>setEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorNode::setEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables all instances of this node. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that we just won't execute our passes. It's your job to change the channel connections accordingly if you have to. A disabled node won't complain when its connections are incomplete in a workspace. </dd></dl>
<dl class="section user"><dt></dt><dd>This function is useful frequently toggling a compositor effect without having to recreate any API resource (which often would involve stalls). </dd></dl>

</div>
</div>
<a id="acf4e9f7b9d8e5b8c61bce6d164185e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4e9f7b9d8e5b8c61bce6d164185e5d">&#9670;&nbsp;</a></span>setLightFixedToShadowMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::setLightFixedToShadowMap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a shadow map as statically updated, and ties the given light to always use that shadow map. </p>
<dl class="section remark"><dt>Remarks</dt><dd>By default <a class="el" href="namespace_ogre.html">Ogre</a> recalculates the shadow maps every single frame (even if nothing has changed). However if you know that whatever a light is illuminating is not changing at all (or barely changing), with static shadow maps you are the one who tells <a class="el" href="namespace_ogre.html">Ogre</a> when to update it (e.g. you may only need to update it three times during the whole level); hence the framerate goes up. Perceived quality may also go up because by default <a class="el" href="namespace_ogre.html">Ogre</a> applies shadow mapping on the closest lights; so shadows flip on and off as you move the camera (because lights that had no shadows get closer while lights that were using shadows get farther away). While often this is desirable, there are cases where the artist may want a particular light to always have shadows (regardless of distance); with static shadow maps you can force that; hence the perceived quality may go up (but that's up to the talent of the artist and the scene in particular). </dd></dl>
<dl class="section user"><dt></dt><dd>Note that for point &amp; spot lights, you have to consider if the light changed (e.g. moved, rotated) or if anything that is or could be lit by the light has moved Directional lights are harder because they depend on the camera placement as well. </dd></dl>
<dl class="section user"><dt></dt><dd>Use setStaticShadowMapDirty to tell <a class="el" href="namespace_ogre.html">Ogre</a> to update the shadow map in the next render. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="namespace_ogre.html">Ogre</a> may call light-&gt;setCastShadows( true ); on the light. </dd></dl>
<dl class="section user"><dt></dt><dd>IMPORTANT: Do not put static and dynamic shadow maps in the same UV atlas. It's asking for trouble and will probably not work. Keep the atlas separate. </dd></dl>
<dl class="section user"><dt></dt><dd>VERY IMPORTANT: You <em>must</em> respect lights are set in the following order:<ol type="1">
<li>Directional</li>
<li>Point</li>
<li>Spot If you have shadow maps defined that support both point &amp; spotlight, and you want to mix both static lights with dynamic ones; set fixed point lights in the first shadow map indices and spotlight in the last indices, to avoid <a class="el" href="namespace_ogre.html">Ogre</a> automatically (e.g.) placing a point light after your static spot light. </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shadowMapIdx</td><td>Shadow map index to tie this light to. If this shadow map index is part of a PSSM split, all PSSM splits will be affected (thus you only need to call it once for any of the split that belong to the same set) </td></tr>
    <tr><td class="paramname">light</td><td><a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene.">Light</a> to tie to the given shadow map. Null pointer disables it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9f91a021268284eec9fecc8913d9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f91a021268284eec9fecc8913d9b9">&#9670;&nbsp;</a></span>setShadowMapsToPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___general.html#ga9870d1f08a71391b8716b43bb2064b2d">LightList</a>* Ogre::CompositorShadowNode::setShadowMapsToPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pass.html">Pass</a> *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_auto_param_data_source.html">AutoParamDataSource</a> *&#160;</td>
          <td class="paramname"><em>autoParamDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startLight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a607c30415819742ad2bcfaa1d3959d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607c30415819742ad2bcfaa1d3959d5a">&#9670;&nbsp;</a></span>setStaticShadowMapDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::CompositorShadowNode::setStaticShadowMapDirty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shadowMapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeLinked</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags a static shadow map as dirty, causing <a class="el" href="namespace_ogre.html">Ogre</a> to update it on the next time this Shadow node gets executed. </p>
<p>If drawing to a texture atlas, multiple shadow maps may be sharing the same texture, thus if you're doing a clear on the whole atlas, you will need to update all of the shadow maps, not just this one. Use includeLinked=true to mark as dirty all static shadow maps that share the same atlas. Set it to false if that's explicitly what you want, or if you're already going to call it for every shadow map (otherwise you will trigger a O(N^2) behavior). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_compositor_shadow_node_8h.html">OgreCompositorShadowNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_compositor_shadow_node.html">CompositorShadowNode</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
